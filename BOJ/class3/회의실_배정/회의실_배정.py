'''
메인 아이디어: 정렬, 그리디

1번 패착 : 완전 탐색으로 생각하여 DFS로 풀었지만, 모든 회의를 넣어본다 안넣어본다 -> 2^N, 최악의 경우 2^100,000 이라서 시간 초과
2번 패착 : 정렬, 그리디로 풀었지만, 회의 시간이 짧은 것부터 집어 넣어, 최적해를 찾을 수 없었음

풀이 방법

회의가 빨리 끝나는 것대로 넣는다. 회의 종료 시간이 같을 경우 빨리 시작하는 것 부터 넣는다.

빨리 끝나는 것부터 넣는다 -> 동일한 목록의 회의 시간 리스트일 때, 빨리 끝나는 회의를 선택하는 것이 다른 회의와 겹치지 않을 최선의 선택임
    더 늦게 끝나는 회의를 선택해서 다른 회의를 못할 가능성은 있지만, 더 빨리 끝나는 회의를 선택해서 할 수 있는 다른 회의를 못하진 않음

회의 종료 시간이 같을 경우 빨리 시작하는 것 부터 넣는다 -> 회의 시작 시간 == 회의 종료 시간인 경우 회의를 하긴 하되 시작과 동시에 끝나기 때문
    
    만약에 늦게 시작하는 것 부터 넣는 경우 1~6, 6~6 회의가 있을 때, 1~6 회의를 넣지 못함
    이전 회의의 종료 시간이 현재 시점에서 가장 빨리 끝나는 회의의 종료 시간이기 때문에 다음 회의는 반드시 6시 이후의 회의를 잡아야하기 때문에 1~6 회의는
    가능한데도 불구하고 해당 로직에선 배제되기 때문
'''

import sys

N = int(sys.stdin.readline().rstrip())
times = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]
sorted_times = sorted(times, key=lambda x: (x[1], -(x[1]-x[0])))
max_count = 0
last_ended = 0
for time in sorted_times:
    start, end = time
    
    if start >= last_ended:
        max_count += 1
        last_ended = end

print(max_count)
